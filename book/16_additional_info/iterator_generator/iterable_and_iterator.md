## Итераторы и итерируемые объекты

Итерация - это общий термин, который описывает процедуру взятия элементов чего-то по очереди.

В более общем смысле, это последовательность инструкций, которая повторяется определенное количество раз или до выполнения указанного условия.

### Итерируемый объект

Итерируемый объект (iterable) - это объект из которого можно получить итератор.

> Более простыми словами, итерируемый объект - это объект, который способен возвращать элементы по одному.

В Python за получение итератора отвечает функция iter():
```python
In [1]: lista = [1, 2, 3]

In [2]: iter(lista)
Out[2]: <list_iterator at 0xb4ede28c>
```

Функция iter() отработает на любом объекте у которого есть метод ```__iter__``` или метод ```__getitem__```.

Метод ```__iter__``` возвращает итератор.
Но, если этого метода нет, функция iter() проверяет нет ли метода ```__getitem__``` - метод, который позволяет получать элементы по индексу.

Если метод ```__getitem__``` есть, возвращается итератор, который проходится по элементам используя индекс (начиная с 0).

На практике, использование метода ```__getitem__``` означает, что все последовательности элементов - это итерируемые объекты. Например, список, кортеж, строка.
Хотя, у этих типов данных есть и метод ```__iter__```.

Примеры итерируемых объектов:
* все последовательности: list, str, tuple
* словари
* файлы

### Итератор

Итератор (iterator) - это объект, который возвращает свои элементы по одному за раз.

С точки зрения Python, это любой объект, у которого есть метод ```__next__```. Этот метод возвращает следующий элемент, если он есть или возвращает исключение StopIteration, когда элементы закончились.

Кроме того, итератор запоминает на каком объекте он остановился в последнюю итерацию.

В Python у каждого итератора присутствует метод ```__iter__``` - то есть, любой итератор является итерируемым объектом. Этот метод просто возвращает сам итератор.


Пример создания итератора из списка:
```python
In [3]: lista = [1, 2, 3]

In [4]: i = iter(lista)
```

Теперь можно использовать функцию next(), которая вызывает метод ```__next__```, чтобы взять следующий элемент:
```python
In [5]: next(i)
Out[5]: 1

In [6]: next(i)
Out[6]: 2

In [7]: next(i)
Out[7]: 3

In [8]: next(i)
------------------------------------------------------------
StopIteration              Traceback (most recent call last)
<ipython-input-8-bed2471d02c1> in <module>()
----> 1 next(i)

StopIteration:
```

После того как элементы закончились, возвращается исключение StopIteration.

Именно такие действия выполяются, когда цикл for проходится по списку:
```python
In [9]: for item in lista:
   ...:     print(item)
   ...:
1
2
3

```

Когда мы перебираем элементы списка, к списку сначала применяется функция iter(), чтобы создать итератор, а затем вызывается его метод ```__next__``` до тех пор, пока не возникнет исключение StopIteration.

Конечно, когда итератор создается из списка или словаря, не до конца понятно зачем он вообще нужен, кроме предоставления возможности проходиться по элементам.

Кроме этого, итераторы полезны тем, что ни отдают элементы по одному.
Например, при работе с файлом, это полезно тем, что в памяти будет находиться не весь файл, а только одна строка файла.

### Файл как итератор

Один из самых распространенных примеров итератора - файл.

Файл r1.txt:
```
!
service timestamps debug datetime msec localtime show-timezone year
service timestamps log datetime msec localtime show-timezone year
service password-encryption
service sequence-numbers
!
no ip domain lookup
!
ip ssh version 2
!
```

Если открыть файл обычной функцией open, мы получим объект, который представляет файл:
```python
In [19]: f = open('r1.txt')
```

Этот объект является итератором, что можно проверить вызвав метод ```__next__```:
```python
In [20]: f.__next__()
Out[20]: '!\n'

In [21]: f.__next__()
Out[21]: 'service timestamps debug datetime msec localtime show-timezone year\n'

```


Аналогичным образом можно перебирать строки в цикле for:
```python
In [26]: for line in f:
    ...:     print(line.rstrip())
    ...:
service timestamps log datetime msec localtime show-timezone year
service password-encryption
service sequence-numbers
!
no ip domain lookup
!
ip ssh version 2
!
```

При работе с файлами, использование файла как итератора не просто позволяет перебирать файл построчно  в каждую итерацию загружена только одна строка.
Это очень важно при работе с большими файлами на тысячи и сотни тысяч строк.
Например, с лог-файлами.

Поэтому при работе с файлами, в Python, чаще всего, используется конструкция вида:
```python
In [27]: with open('r1.txt') as f:
    ...:     for line in f:
    ...:         print(line.rstrip())
    ...:
!
service timestamps debug datetime msec localtime show-timezone year
service timestamps log datetime msec localtime show-timezone year
service password-encryption
service sequence-numbers
!
no ip domain lookup
!
ip ssh version 2
!
```

### itertools

В Python есть отдельный модуль itertools в котором находятся итераторы и средства работы с ними.

Например, в этом модуле есть бесконечные итераторы:
* count() - этот итератор возвращает номера, начиная с указанного и используя указанный шаг
* cycle() - повторяет циклически элементы
* repeat() - повторяет элемент


Пример count():
```python
In [28]: import itertools

In [29]: count_nums = itertools.count(0,2)

In [30]: count_nums
Out[30]: count(0, 2)

In [31]: for _ in range(10):
    ...:     print(next(count_nums))
    ...:
0
2
4
6
8
10
12
14
16
18

```

Например, count может пригодиться в zip, чтобы сгенерировать номера элементов:
```python
In [32]: nums = list(range(100, 201, 10))

In [33]: nums
Out[33]: [100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]

In [34]: list(zip(itertools.count(), nums))
Out[34]:
[(0, 100),
 (1, 110),
 (2, 120),
 (3, 130),
 (4, 140),
 (5, 150),
 (6, 160),
 (7, 170),
 (8, 180),
 (9, 190),
 (10, 200)]
```

Пример использования cycle():
```python
In [37]: cycle_letters = itertools.cycle('ABCD')

In [38]: for _ in range(10):
    ...:     print(next(cycle_letters))
    ...:
A
B
C
D
A
B
C
D
A
B

```

Функция islice создает итератор, который возвращает элементы итерируемого объекта.
Она поддерживает такой же синтаксис, как и функция range:
```python
In [58]: from itertools import islice

In [59]: islice(range(100,200,5), 5)
Out[59]: <itertools.islice at 0xb4f6c57c>

In [60]: list(islice(range(100,200,5), 5))
Out[60]: [100, 105, 110, 115, 120]

In [61]: list(islice(range(100,200,5), 5, 10))
Out[61]: [125, 130, 135, 140, 145]

In [62]: list(islice(range(100,200,5), 5, 10, 2))
Out[62]: [125, 135, 145]

```

> islice не поддерживает отрицательные индексы


С помощью функций, которые находятся в модуле itertools, можно создавать полезные функции для работы с итерируемыми объектами или итератораторами.

Пример из документации модуля:
```python
In [47]: from itertools import islice

In [48]: def take(n, iterable):
    ...:     "Return first n items of the iterable as a list"
    ...:     return list(islice(iterable, n))
    ...:
```

Функция take возвращает указанное количество элементов из итерируемого объекта:
```python
In [52]: a = [1,2,3,4,5,6,7,8]

In [53]: b = range(100,200,5)

In [54]: take(5, a)
Out[54]: [1, 2, 3, 4, 5]

In [55]: take(5, b)
Out[55]: [100, 105, 110, 115, 120]

```

