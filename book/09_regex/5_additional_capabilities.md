## Дополнительные возможности регулярных выражений

### re.split

Функция split работает аналогично методу split в строках.  
Но в функции re.split, можно использовать регулярные выражения, а значит разделять строку на части по более сложным условиям.

Например, строку ospf\_route надо разбить на элементы, по пробелам \(как в методе str.split\):

```python
In [1]: ospf_route = 'O     10.0.24.0/24 [110/41] via 10.0.13.3, 3d18h, FastEthernet0/0'

In [2]: re.split(' +', ospf_route)
Out[2]:
['O',
 '10.0.24.0/24',
 '[110/41]',
 'via',
 '10.0.13.3,',
 '3d18h,',
 'FastEthernet0/0']
```

Аналогичным образом можно избавиться и от запятых:

```python
In [3]: re.split('[ ,]+', ospf_route)
Out[3]:
['O',
 '10.0.24.0/24',
 '[110/41]',
 'via',
 '10.0.13.3',
 '3d18h',
 'FastEthernet0/0']
```

И, если нужно, от квадратных скобок:

```python
In [4]: re.split('[ ,\[\]]+', ospf_route)
Out[4]: ['O', '10.0.24.0/24', '110/41', 'via', '10.0.13.3', '3d18h', 'FastEthernet0/0']
```

У функции split есть особенность работы с группами\(выражения в круглых скобках\).  
Если указать то же выражение с помощью круглых скобок, в итоговый список попадут и разделители.

Например, в выражении как разделитель добавлено слово via:

```python
In [5]: re.split('(via|[ ,\[\]])+', ospf_route)
Out[5]:
['O',
 ' ',
 '10.0.24.0/24',
 '[',
 '110/41',
 ' ',
 '10.0.13.3',
 ' ',
 '3d18h',
 ' ',
 'FastEthernet0/0']
```

Для отключения такого поведения, надо сделать группу noncapture.  
То есть, отключить запоминание элементов группы:

```python
In [6]: re.split('(?:via|[ ,\[\]])+', ospf_route)
Out[6]: ['O', '10.0.24.0/24', '110/41', '10.0.13.3', '3d18h', 'FastEthernet0/0']
```

### re.sub

Функция re.sub работает аналогично методу replace в строках.  
Но в функции re.sub, можно использовать регулярные выражения, а значит делать замены по более сложным условиям.

Заменим запятые, квадратные скобки и слово via на пробел в строке ospf\_route:

```python
In [7]: ospf_route = 'O    10.0.24.0/24 [110/41] via 10.0.13.3, 3d18h, FastEthernet0/0'

In [8]: re.sub('(via|[,\[\]])', ' ', ospf_route)
Out[8]: 'O        10.0.24.0/24  110/41    10.0.13.3  3d18h  FastEthernet0/0'
```

С помощью re.sub можно трансформировать строку.  
Например, преобразовать строку mac\_table таким образом:

```python
In [9]: mac_table = '''
   ...:  100    aabb.cc10.7000    DYNAMIC     Gi0/1
   ...:  200    aabb.cc20.7000    DYNAMIC     Gi0/2
   ...:  300    aabb.cc30.7000    DYNAMIC     Gi0/3
   ...:  100    aabb.cc40.7000    DYNAMIC     Gi0/4
   ...:  500    aabb.cc50.7000    DYNAMIC     Gi0/5
   ...:  200    aabb.cc60.7000    DYNAMIC     Gi0/6
   ...:  300    aabb.cc70.7000    DYNAMIC     Gi0/7
   ...: '''

In [10]: print(re.sub(' *(\d+) +([a-f0-9]+)\.([a-f0-9]+)\.([a-f0-9]+) +\w+ +(\S+)', r'\1 \2:\3:\4 \5', mac_table))

100 aabb:cc10:7000 Gi0/1
200 aabb:cc20:7000 Gi0/2
300 aabb:cc30:7000 Gi0/3
100 aabb:cc40:7000 Gi0/4
500 aabb:cc50:7000 Gi0/5
200 aabb:cc60:7000 Gi0/6
300 aabb:cc70:7000 Gi0/7
```

Регулярное выражение разделено на группы:

* \(\d+\) - первая группа. Сюда попадет номер VLAN
* \(\[a-f,0-9\]+\).\(\[a-f,0-9\]+\).\(\[a-f,0-9\]+\) - три следующие группы \(2, 3, 4\) описывают MAC-адрес
* \(\S+\) - пятая группа. Описывает интерфейс.

Во втором регулярном выражении эти группы используются.  
Для того чтобы сослаться на группу, .использует обратный слеш и номер группы.  
Чтобы не пришлось экранировать обратный слеш, используется raw строка.

В итоге вместо номеров групп, будут подставлены соответствующие подстроки.  
Для примера, также изменен формат записи MAC-адреса.

### re.DOTALL

С помощью регулярных выражений можно работать и с многострочной строкой.

Например, из строки table надо получить только строки с соответствиями VLAN-MAC-interface:

```python
In [11]: table = '''
    ...: sw1#sh mac address-table
    ...:           Mac Address Table
    ...: -------------------------------------------
    ...:
    ...: Vlan    Mac Address       Type        Ports
    ...: ----    -----------       --------    -----
    ...:  100    aabb.cc10.7000    DYNAMIC     Gi0/1
    ...:  200    aabb.cc20.7000    DYNAMIC     Gi0/2
    ...:  300    aabb.cc30.7000    DYNAMIC     Gi0/3
    ...:  100    aabb.cc40.7000    DYNAMIC     Gi0/4
    ...:  500    aabb.cc50.7000    DYNAMIC     Gi0/5
    ...:  200    aabb.cc60.7000    DYNAMIC     Gi0/6
    ...:  300    aabb.cc70.7000    DYNAMIC     Gi0/7
    ...: '''
```

Конечно, в этом случае можно разделить строку на части и работать с каждой строкой отдельно.  
Но можно получить часть с MAC-адресами и без разделения.

В этом примере нужно вырезать часть вывода, которая содержит соответствия.

В этом выражении описана строка с MAC-адресом:

```python
In [12]: m = re.search(' *\d+ +[a-f0-9.]+ +\w+ +\S+', table)
```

В результат попадет первая строка с MAC-адресом:

```python
In [13]: m.group()
Out[13]: ' 100    aabb.cc80.7000    DYNAMIC     Gi0/1'
```

Учитывая то, что по умолчанию регулярные выражения жадные, можно получить все соответствия таким образом:

```python
In [14]: m = re.search('( *\d+ +[a-f0-9.]+ +\w+ +\S+\n)+', table)

In [15]: print(m.group())
 100    aabb.cc10.7000    DYNAMIC     Gi0/1
 200    aabb.cc20.7000    DYNAMIC     Gi0/2
 300    aabb.cc30.7000    DYNAMIC     Gi0/3
 100    aabb.cc40.7000    DYNAMIC     Gi0/4
 500    aabb.cc50.7000    DYNAMIC     Gi0/5
 200    aabb.cc60.7000    DYNAMIC     Gi0/6
 300    aabb.cc70.7000    DYNAMIC     Gi0/7
```

Тут описана строка с MAC-адресом, перевод строки и указано, что это выражение должно повторяться, как минимум, один раз.

Получается, что в данном случае надо получить все строки, начиная с первого соответствия VLAN-MAC-интерфейс.

Это можно описать таким образом:

```python
In [16]: m = re.search(' *\d+ +[a-f0-9.]+ +\w+ +\S+.*', table)

In [17]: print(m.group())
 100    aabb.cc10.7000    DYNAMIC     Gi0/1
```

Пока что, в результате только одна строка, так как по умолчанию точка не включает в себя перевод строки.  
Но, если добавить специальный флаг, re.DOTALL, точка будет включать и перевод строки и в результат попадут все соответствия:

```python
In [18]: m = re.search(' *\d+ +[a-f0-9.]+ +\w+ +\S+.*', table, re.DOTALL)

In [19]: print(m.group())
 100    aabb.cc10.7000    DYNAMIC     Gi0/1
 200    aabb.cc20.7000    DYNAMIC     Gi0/2
 300    aabb.cc30.7000    DYNAMIC     Gi0/3
 100    aabb.cc40.7000    DYNAMIC     Gi0/4
 500    aabb.cc50.7000    DYNAMIC     Gi0/5
 200    aabb.cc60.7000    DYNAMIC     Gi0/6
 300    aabb.cc70.7000    DYNAMIC     Gi0/7
```

### Дополнительные ресурсы

* [Regular Expression HOWTO](https://docs.python.org/3.6/howto/regex.html)
* [Множество примеров использования регулярных выражений от основ до более сложных тем](http://www.rexegg.com/)
* [Визуализация регулярного выражения](https://regexper.com/)
* [Python 3 Module of the Week](https://pymotw.com/3/re/)



