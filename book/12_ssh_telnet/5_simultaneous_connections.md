# Параллельные сессии

Когда нужно опросить много устройств, выполнение подключений поочередно будет достаточно долгим.
Конечно, это будет быстрее, чем подключение вручную, но хотелось бы получать отклик как можно быстрее.

> Все эти "долго" и "быстрее" относительные понятия, но в этом разделе мы научимся и конкретно измерять, сколько отрабатывал скрипт, чтобы сравнить, насколько быстрее будет выполняться подключение.

Для параллельного подключения к устройствам в курсе используются модули:
* threading
* multiprocessing
* concurrent.futures

## Измерение времени выполнения скрипта

Для оценки времени выполнения скрипта есть несколько вариантов.
В курсе используются самые простые варианты:
* утилита Linux time
* и модуль Python datetime

> Рассматриваются оба варианта, на тот случай, если используется Windows.

При оценке времени выполнения скрипта в данном случае не важна высокая точность. 
Главное - сравнить время выполнения скрипта в разных вариантах.

### ```time```

Утилита time в Linux позволяет замерить время выполнения скрипта. Например:
```
$ time python thread_paramiko.py
...
real    0m4.712s
user    0m0.336s
sys     0m0.064s
```

Нас интересует real время. В данном случае это 4.7 секунд.

Для использования утилиты time достаточно написать time перед строкой запуска скрипта.

### ```datetime```

Второй вариант - модуль datetime.
Этот модуль позволяет работать со временем и датами в Python.

Пример использования:
```python
from datetime import datetime
import time

start_time = datetime.now()

#Тут выполняются действия
time.sleep(5)

print(datetime.now() - start_time)
```

Результат выполнения:
```
$ python test.py
0:00:05.004949
```


## Проблемы с потоками в Python (CPython)

<br>
> Подробности, которые описаны ниже, не обязательно знать. В общем случае, лучше использовать модуль multiprocessing и можно плюс-минус не задумываться обо всех этих особенностях. 


Для начала нам нужно разобраться с терминами:
* процесс (process) - это, грубо говоря, запущенная программа. Процессу выделяются отдельные ресурсы: память, процессорное время
* поток (thread) - это единица исполнения в процессе. Потоки разделяют ресурсы процесса, к которому они относятся.

Python (а точнее, CPython - реализация, которая используется в курсе) оптимизирован для работы в однопоточном режиме. Это хорошо, если в программе используется только один поток.

И, в то же время, у Python есть определенные нюансы работы в многопоточном режиме. Связаны они с тем, что CPython использует GIL (global interpreter lock).

GIL не дает нескольким потокам исполнять одновременно код Python.
Если не вдаваться в подробности, то GIL можно представить как некий переходящий флаг, который разрешает потокам выполняться.
У кого флаг, тот может выполнять работу.

Флаг передается либо каждые сколько-то инструкций Python, либо, например, когда выполняются какие-то операции ввода-вывода.

Поэтому получается, что разные потоки не будут выполняться параллельно, а программа просто будет между ними переключаться, выполняя их в разное время.

Но не всё так плохо. Если в программе есть некое "ожидание": пакетов из сети, запроса пользователя, пауза типа sleep - то в такой программе потоки будут выполняться как будто параллельно.
А всё потому, что во время таких пауз флаг (GIL) можно передать другому потоку.

Но тут также нужно быть осторожным, так как такой результат может наблюдаться на небольшом количестве сессий, но может ухудшиться с ростом количества сессий.

В любом случае, у потоков в Python есть свои области применения. В следующих разделах рассматривается, как использовать потоки для подключения по Telnet/SSH. И проверяется, какое суммарное время будет занимать исполнение скрипта, по сравнению с последовательным исполнением и с использованием процессов.

## Процессы

Обычно, чтобы не погружаться во все эти тонкости с GIL и потоками в Python, проще просто использовать модуль multiprocessing и всё.

Если же вы столкнетесь с ситуацией, где вам нужно будет использовать потоки, скорее всего, к тому времени вы уже разберетесь с этим вопросом. Как минимум, достаточно в целом знать об описанных выше особенностях.

## Дополнительная информация

Если вы хотите подробнее разобраться с этими вопросами или захотите вернуться к ним позже, несколько ссылок:
* GIL:
 * [GIL](http://asvetlov.blogspot.com/2011/07/gil.html) (на русском)
 * [Inside the Python GIL](http://www.dabeaz.com/python/GIL.pdf)
* Отличная статья [Python threads and the GIL](http://jessenoller.com/blog/2009/02/01/python-threads-and-the-global-interpreter-lock)
* Коротко о GIL, threads, processes:
 * http://stackoverflow.com/questions/3044580/multiprocessing-vs-threading-python
 * http://stackoverflow.com/questions/18114285/python-what-are-the-differences-between-the-threading-and-multiprocessing-modul

