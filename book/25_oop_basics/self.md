## Создание класса

> Обратите внимание, что тут основы поясняются с учетом того, что у читающего нет опыта работы с ООП. Некоторые примеры не очень правильны с точки зрения идеологии Python, но помогают лучше понять происходящее. В конце даются пояснения как это правильней делать.

Для создания классов в питоне используется ключевое слово `class`. Самый простой класс, который можно создать в Python:
```python
In [1]: class Switch:
   ...:     pass
   ...:
```

> Имена классов: в Python принято писать имена классов в формате CamelCase.

Для создания экземпляра класса, надо вызвать класс:
```python
In [2]: sw1 = Switch()

In [3]: print(sw1)
<__main__.Switch object at 0xb44963ac>
```

Используя точечную нотацию, можно не только получать значения переменных экземпляра, но и создавать новые:
```python
In [5]: sw1.hostname = 'sw1'

In [6]: sw1.model = 'Cisco 3850'
```

В другом экземпляре класса Switch, переменные могут быть другие:
```python
In [7]: sw1 = Switch()

In [8]: sw2.hostname = 'sw2'

In [9]: sw2.model = 'Cisco 3750'
```

Посмотреть значение переменных экземпляра можно используя ту же точечную нотацию:
```python
In [10]: sw1.model
Out[10]: 'Cisco 3850'

In [11]: sw2.model
Out[11]: 'Cisco 3750'
```

### Создание метода

Прежде чем мы начнем разбираться с методами класса, посмотрим пример функции, которая ожидает как аргумент экземпляр класса Switch и выводит информацию о нем, используя переменные экземпляра hostname и mode:
```python
In [41]: def info(sw_obj):
    ...:     print('Hostname: {}\nModel: {}'.format(sw_obj.hostname, sw_obj.model))
    ...:

In [42]: sw1 = Switch('sw1', 'Cisco 3850')

In [43]: info(sw1)
Hostname: sw1
Model: Cisco 3850
```

В функции info параметр `sw_obj` ожидает экземпляр класса `Switch`. Скорее всего, в это примере нет ничего нового, ведь аналогичным образом ранее мы писали функции, которые ожидают строку, как аргумент, а затем вызывают какие-то методы у этой строки.

Этот пример поможет разобраться с методом info, который мы добавим в класс Switch.


Для добавления метода, необходимо создать функцию внутри класса:
```python
In [15]: class Switch:
    ...:     def info(self):
    ...:         print('Hostname: {}\nModel: {}'.format(self.hostname, self.model))
    ...:
```

Если присмотреться, метод info выглядит точно так же, как функция info, только вместо имени sw_obj, используется self. Почему тут используется странное имя self, мы разберемся позже, а пока посмотрим как вызвать метод info:
```python
In [16]: sw1 = Switch()

In [17]: sw1.hostname = 'sw1'

In [18]: sw1.model = 'Cisco 3850'

In [19]: sw1.info()
Hostname: sw1
Model: Cisco 3850
```

В примере выше сначала создается экземпляр класса Switch, затем в экземпляр добавляются переменные hostname и model, и только после этого вызывается метод info.
Метод info выводит информацию про коммутатор, используя значения, которые хранятся в переменных экземпляра.

Вызов метода отличается, от вызова функции: мы не передаем ссылку на экземпляр класса Switch. Нам это не нужно, потому что мы вызываем метод у самого экземпляра. Еще один непонятный момент - зачем же мы тогда писали self.

Все дело в том, что Python преобразует такой вызов:
```python
In [39]: sw1.info()
Hostname: sw1
Model: Cisco 3850
```

Вот в такой:
```python
In [38]: Switch.info(sw1)
Hostname: sw1
Model: Cisco 3850
```

Во втором случае, в параметре self уже больше смысла, он действительно принимает ссылку на экземпляр и на основании этого выводит информацию.

С точки зрения использования объектов, удобней вызывать методы используя первый вариант синтаксиса, поэтому, практически всегда именно он и используется.

> При вызове метода экземпляра класса, ссылка на экземпляр передается первым аргументом. При этом, экземпляр передается неявно, но параметр надо указывать явно.

Такое преобразование не является особенностью пользовательских классов и работает и для встроенных типов данных аналогично. Например, стандартный способ вызова метода append в списке, выглядит так:
```python
In [4]: a = [1,2,3]

In [5]: a.append(5)

In [6]: a
Out[6]: [1, 2, 3, 5]
```

При этом, то же самое можно сделать и используя второй вариант, вызова через класс:
```python
In [7]: a = [1,2,3]

In [8]: list.append(a, 5)

In [9]: a
Out[9]: [1, 2, 3, 5]
```

### self

Параметр self указывался выше  в определении методов, а также при использовании переменных экземпляра в методе.
Параметр self это ссылка на конкретный экземпляр класса. При этом, само имя self неявляется особенным, а лишь договоренностью. Вместо self можно использовать другое имя, но так делать не стоит.

Пример с использованием другого имени, вместо self:
```python
In [15]: class Switch:
    ...:     def info(sw_object):
    ...:         print('Hostname: {}\nModel: {}'.format(sw_object.hostname, sw_object.model))
    ...:
```

Работать все будет аналогично:
```python
In [16]: sw1 = Switch()

In [17]: sw1.hostname = 'sw1'

In [18]: sw1.model = 'Cisco 3850'

In [19]: sw1.info()
Hostname: sw1
Model: Cisco 3850
```

> Хотя технически использовать другое имя можно, всегда используйте self.

Во всех "обычных" методах класса первым параметром всегда будет self. Кроме того, создание переменной экземпляра внутри класса также выполняется через self.

Пример класса Switch с новым методом generate_interfaces: метод generate_interfaces должен сгенерировать список с интерфейсами на основании указанного типа и количества и создать переменную в экземпляре класса. Для начала, вариант создания обычно переменной внутри метода:
```python
In [5]: class Switch:
   ...:     def generate_interfaces(self, intf_type, number_of_intf):
   ...:         interfaces = ['{}{}'.format(intf_type, number) for number in range(1, number_of_intf+1)]
   ...:
```

В этом случае, в экземплярах класса не будет переменной interfaces:
```python
In [6]: sw1 = Switch()

In [7]: sw1.generate_interfaces('Fa', 10)

In [8]: sw1.interfaces
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-8-e6b457e4e23e> in <module>()
----> 1 sw1.interfaces

AttributeError: 'Switch' object has no attribute 'interfaces'
```

Этой переменной нет, потому что она существует только внутри метода, а область видимости у метода такая же, как и у функции. Даже другие методы одного и того же класса, не видят переменные в других методах.

Чтобы список с интерфейсами был доступен как переменная в экзеплярах, надо присвоить значение в self.interfaces:
```python
In [9]: class Switch:
   ...:     def info(self):
   ...:         print('Hostname: {}\nModel: {}'.format(self.hostname, self.model))
   ...:
   ...:     def generate_interfaces(self, intf_type, number_of_intf):
   ...:         interfaces = ['{}{}'.format(intf_type, number) for number in range(1, number_of_intf+1)]
   ...:         self.interfaces = interfaces
   ...:
```

Теперь, после вызова метода generate_interfaces, в экзепляре создается переменная interfaces:
```python
In [10]: sw1 = Switch()

In [11]: sw1.generate_interfaces('Fa', 10)

In [12]: sw1.interfaces
Out[12]: ['Fa1', 'Fa2', 'Fa3', 'Fa4', 'Fa5', 'Fa6', 'Fa7', 'Fa8', 'Fa9', 'Fa10']
```


### Метод `__init__`

Для корректной работы метода info, необходимо чтобы у экземпляра были переменные hostname и model. Если этих переменных нет, возникнет ошибка:
```python
In [15]: class Switch:
    ...:     def info(self):
    ...:         print('Hostname: {}\nModel: {}'.format(self.hostname, self.model))
    ...:

In [59]: sw2 = Switch()

In [60]: sw2.info()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-60-5a006dd8aae1> in <module>()
----> 1 sw2.info()

<ipython-input-57-30b05739380d> in info(self)
      1 class Switch:
      2     def info(self):
----> 3         print('Hostname: {}\nModel: {}'.format(self.hostname, self.model))

AttributeError: 'Switch' object has no attribute 'hostname'
```

Практически всегда, при создании объекта, у него есть какие-то начальные данные. Например, чтобы создать подключение к оборудование с помощью netmiko, надо передать параметры подключения.

В Python эти начальные данные про объект указываются в методе `__init__`. Метод `__init__` выполняется после того как Python создал новый экземпляр и, при этом, методу `__init__` передаются аргументы с которыми был создан экземпляр:
```python
In [32]: class Switch:
    ...:     def __init__(self, hostname, model):
    ...:         self.hostname = hostname
    ...:         self.model = model
    ...:
    ...:     def info(self):
    ...:         print('Hostname: {}\nModel: {}'.format(self.hostname, self.model))
    ...:
```

Обратите внимание на то, что переменные созданы у экземпляра: `self.model`.

Теперь, при создании экземпляра класса Switch, обязательно надо указать hostname и model:
```python
In [33]: sw1 = Switch('sw1', 'Cisco 3850')
```

И, соответственно, метод info отрабатывает без ошибок:
```
In [36]: sw1.info()
Hostname: sw1
Model: Cisco 3850
```

> Метод `__init__` иногда называют конструктором класса, хотя технически в Python сначала выполняется метод `__new__`, а затем `__init__`. В большинстве случаев, метод `__new__` использовать не нужно.

Важной особенностью метода `__init__` является то, что он не должен ничего возвращать. Python сгенерирует исключение, если попытаться это сделать.

### Область видимости

У каждого метода в классе своя локальная область видимости. Это значит, что один метод класса не видит переменные другого метода класса. Для того чтобы переменные были доступны, надо присваивать их экземпляру через `self.name`.

> По сути метод - это функция привязанная к объекту. То есть все нюансы, которые касаются функция, относятся и к методам.

Переменные экземпляра доступны в другом методе, потому что каждому методу первым аргументом передается сам экзепляр. В примере ниже, в методе `__init__` переменные hostname и model присваиваются экземпляру, а затем в info используются, за счет того, что экземпляр передается первым аргументом:
```python
In [32]: class Switch:
    ...:     def __init__(self, hostname, model):
    ...:         self.hostname = hostname
    ...:         self.model = model
    ...:
    ...:     def info(self):
    ...:         print('Hostname: {}\nModel: {}'.format(self.hostname, self.model))
    ...:
```

### Переменные класса

Помимо переменных экземпляра, существуют также переменные класса. Они создаются, при указании переменных внутри самого класса, не метода:
```python
In [27]: class A:
    ...:     var_a = 5
    ...:
    ...:     def method(self):
    ...:         pass
    ...:
```

Теперь не только у класса, но и у каждого экземпляра класса будет переменная `var_a`:
```python
In [40]: A.var_a
Out[40]: 5

In [30]: a1 = A()

In [31]: a1.var_a
Out[31]: 5

In [32]: a2 = A()

In [33]: a2.var_a
Out[33]: 5
```

Важный момент при использовании переменных класса, то что внутри метода к ним все равно надо обращаться через имя класса (или self, но через имя класса лучше, так как тогда понятно, что это переменная класса). Для начала, вариант обращения без имени класса:
```python
In [37]: class A:
    ...:     var_a = 5
    ...:
    ...:     def method(self):
    ...:         print(var_a)
    ...:

In [38]: a1 = A()

In [39]: a1.method()
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-39-921b8753dbee> in <module>()
----> 1 a1.method()

<ipython-input-37-ef925c4e39d3> in method(self)
      3
      4     def method(self):
----> 5         print(var_a)
      6

NameError: name 'var_a' is not defined
```

И правильный вариант:
```python
In [47]: class A:
    ...:     var_a = 5
    ...:
    ...:     def method(self):
    ...:         print(A.var_a)
    ...:

In [48]: a1 = A()

In [49]: a1.method()
5
```
