## Создание класса

Для создания классов в питоне используется ключевое слово `class`. Самый простой класс, который можно создать в Python:
```python
In [1]: class Switch:
   ...:     pass
   ...:
```

> Имена классов: в Python принято писать имена классов в формате CamelCase.

Для создания экземпляра класса, надо вызвать класс:
```python
In [2]: sw1 = Switch()

In [3]: print(sw1)
<__main__.Switch object at 0xb44963ac>
```

Используя точечную нотацию, можно не только получать значения переменных экземпляра, но и создавать новые:
```python
In [5]: sw1.hostname = 'sw1'

In [6]: sw1.model = 'Cisco 3850'
```

В другом экземпляре класса Switch, переменные могут быть другие:
```python
In [7]: sw1 = Switch()

In [8]: sw2.hostname = 'sw2'

In [9]: sw2.model = 'Cisco 3750'
```

Посмотреть значение переменных экземпляра можно используя ту же точечную нотацию:
```python
In [10]: sw1.model
Out[10]: 'Cisco 3850'

In [11]: sw2.model
Out[11]: 'Cisco 3750'
```

### Методы

Прежде чем мы начнем разбираться с методами класса, посмотрим пример функции, которая ожидает как аргумент экземпляр класса Switch и выводит информацию о нем, используя переменные экземпляра hostname и mode:
```python
In [41]: def info(sw_obj):
    ...:     print('Hostname: {}\nModel: {}'.format(sw_obj.hostname, sw_obj.model))
    ...:

In [42]: sw1 = Switch('sw1', 'Cisco 3850')

In [43]: info(sw1)
Hostname: sw1
Model: Cisco 3850
```

В функции info параметр sw_obj ожидает экземпляр класса Switch. Скорее всего, в это примере нет ничего нового, ведь аналогичным образом ранее мы писали функции, которые ожидают строку, как аргумент, а затем вызывают какие-то методы у этой строки.

Этот пример поможет разобраться с методом info, который мы добавим в класс Switch.


Для добавления метода, необходимо создать функцию внутри класса:
```python
In [15]: class Switch:
    ...:     def info(self):
    ...:         print('Hostname: {}\nModel: {}'.format(self.hostname, self.model))
    ...:
```

Если присмотреться, метод info выглядит точно так же, как функция info, только вместо имени sw_obj, используется self. Почему тут используется странное имя self, мы разберемся позже, а пока посмотрим как вызвать метод info:
```python
In [16]: sw1 = Switch()

In [17]: sw1.hostname = 'sw1'

In [18]: sw1.model = 'Cisco 3850'

In [19]: sw1.info()
Hostname: sw1
Model: Cisco 3850
```

В примере выше сначала создается экземпляр класса Switch, затем в экземпляр добавляются переменные hostname и model, и только после этого вызывается метод info.
Метод info выводит информацию про коммутатор, используя значения, которые хранятся в переменных экземпляра.

Вызов метода отличается, от вызова функции: мы не передаем ссылку на экземпляр. Но нам это и  не нужно, потому что мы вызываем метод у самого экземпляра. Еще один непонятный момент - зачем же мы тогда писали self.

Все дело в том, что Python преобразует такой вызов:
```python
In [39]: sw1.info()
Hostname: sw1
Model: Cisco 3850
```

Вот в такой:
```python
In [38]: Switch.info(sw1)
Hostname: sw1
Model: Cisco 3850
```

Во втором случае, в параметре self уже больше смысла, он действительно принимает ссылку на экземпляр и на основании этого выводит информацию.

С точки зрения использования объектов, удобней вызывать методы используя первый вариант синтаксиса, поэтому, практически всегда именно он и используется.

Такое преобразование не является особенностью пользовательских классов и работает и для встроенных типов данных аналогично. Например, стандартный способ вызова метода append в списке, выглядит так:
```python
In [4]: a = [1,2,3]

In [5]: a.append(5)

In [6]: a
Out[6]: [1, 2, 3, 5]
```

При этом, то же самое можно сделать и используя второй вариант, вызова через класс:
```python
In [7]: a = [1,2,3]

In [8]: list.append(a, 5)

In [9]: a
Out[9]: [1, 2, 3, 5]
```

### Метод `__init__`

Для корректной работы метода info, необходимо чтобы у экземпляра были переменные hostname и model. Если этих переменных нет, возникнет ошибка:
```python
In [59]: sw2 = Switch()

In [60]: sw2.info()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-60-5a006dd8aae1> in <module>()
----> 1 sw2.info()

<ipython-input-57-30b05739380d> in info(self)
      1 class Switch:
      2     def info(self):
----> 3         print('Hostname: {}\nModel: {}'.format(self.hostname, self.model))

AttributeError: 'Switch' object has no attribute 'hostname'
```

Практически всегда, когда создается какой-то объект, у него есть какие-то начальные данные. Например, чтобы создать подключение к оборудование с помощью netmiko, надо передать параметры подключения.

В Python эти начальные данные про объект указываются в методе `__init__`. Метод `__init__` выполняется после того как Python создал новый экземпляр и, при этом, методу `__init__` передаются аргументы с которыми был создан экземпляр:
```python
In [32]: class Switch:
    ...:     def __init__(self, hostname, model):
    ...:         self.hostname = hostname
    ...:         self.model = model
    ...:
    ...:     def info(self):
    ...:         print('Hostname: {}\nModel: {}'.format(self.hostname, self.model))
    ...:
```

> Метод `__init__` иногда называют конструктором класса, хотя технически в Python сначала выполняется метод `__new__`, а затем `__init__`. В большинстве случаев, метод `__new__` использовать не нужно.

Теперь, при создании экземпляра класса Switch, обязательно надо указать hostname и model:
```python
In [33]: sw1 = Switch('sw1', 'Cisco 3850')
```

И, соответственно, метод info отрабатывает без ошибок:
```
In [36]: sw1.info()
Hostname: sw1
Model: Cisco 3850
```

Внутри метода __init__ мы создаем переменные экземпляра таким образом
```python
class Switch:
    def __init__(self, hostname, model):
        self.hostname = hostname
        self.model = model
```


### self

Наступило время разобраться с self. 
Параметр self указывался выше  в определении методов, а также при использовании переменных экземпляра в методе.

Параметр self это ссылка на конкретный экземпляр класса. 

При создании метода __init__ указаны три параметра:
```python
class Switch:
    def __init__(self, hostname, model):
        self.hostname = hostname
        self.model = model
```

При этом, при создании экземпляра, передаются только два аргумента:
```python
sw1 = Switch('sw1', 'Cisco 3850')
```

При вызове метода, ссылка на экземпляр передается первым аргументом. При этом, экземпляр передается неявно, но параметр надо указывать явно.
```python
In [39]: sw1.info()
Hostname: sw1
Model: Cisco 3850
```

При вызове метода экземпляра, Python преобразует вызов в вызов метода в классе и при этом передает экземпляр класса как первый аргумент.
```python
In [38]: Switch.info(sw1)
Hostname: sw1
Model: Cisco 3850

```

И соответственно, чтобы создать переменные в экземпляре класса, в методе __init__ выполняется:
```python
In [40]: class Switch:
    ...:     def __init__(self, hostname, model):
    ...:         self.hostname = hostname
    ...:         self.model = model
    ...:
```


